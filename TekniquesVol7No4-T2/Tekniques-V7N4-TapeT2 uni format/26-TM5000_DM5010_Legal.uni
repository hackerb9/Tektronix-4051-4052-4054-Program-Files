4000 REM **** FILE 3 - DM5010 ****4005 F$="DM5010 Settings Test"4010 FOR L1=1 TO L4015 PRINT @D0:"<<";F$;">>  Loop ";L1;" of ";L;"     Unit ";P(N4)4020 DELETE I,J,K,K1,K2,K34100 REM4105 REM                                               *** VERIFY ID ***4110 REM4115 A$="ID TEK/DM5010,V"4120 GOSUB 27004200 REM4205 REM                            *** VERIFY SETTINGS AFTER 'INIT' ***4210 REM4215 A$="INIT;SET?"4220 GOSUB 5004225 GOSUB 6004240 I$="DCV -1.E+3;AVE 2;RATIO 1., 0.;DBR 1.;LIMITS 0., 0.;CALC OFF;"4245 I$=I$&"NULL 0.;DIGIT 4.5;LFR OFF;MODE RUN;SOURCE FRONT;DT OFF;"4250 I$=I$&"MONITOR OFF;OPC OFF;OVER OFF;USER OFF;RQS ON;"4285 IF B$=I$ THEN 44004290 GOSUB 58004400 REM4405 REM                                              ***** 'TEST' *****4410 REM4415 A$="TEST"4420 GOSUB 5004430 CALL "WAIT",14440 GOSUB 6004445 REM ^^^ Get results of 'TEST'4450 I$="TEST 0;"4455 IF B$=I$ THEN 46004460 REM  Do a 'GETSTA' to check status byte of inst.4465 WBYTE @95,63,24,64+P(N4):4470 RBYTE X4475 WBYTE @95,25:4480 IF X=65 THEN 44954485 PRINT @D0:"***** Status not POWER UP after 'TEST' command."4490 PRINT @D0:"Staus byte returned was: ";X4495 GOSUB 58004600 REM4605 REM                *** MONITOR, OPC, OVER, RQS, USER, LFR ***4610 REM4615 RESTORE 59154620 V=04625 FOR I=1 TO 64630 READ H$4635 FOR J=1 TO 34640 GOSUB J OF 5300,5350,53004645 NEXT J4650 NEXT I4655 A$="RQS ON;"4660 GOSUB 5004700 REM4705 REM                           *** CALC, DT, DIGIT, MODE, SOURCE ***4710 REM4715 V=04720 RESTORE 59654725 FOR I=1 TO 54730 READ H$,K4735 FOR J=1 TO K4740 READ S$4745 GOSUB 54004750 NEXT J4755 NEXT I4800 REM4805 REM                                    *** ACDC, ACV, DCV, OHMS ***4810 REM4815 V=14820 RESTORE 60154825 FOR I=1 TO 44830 READ H$,K14835 FOR K=1 TO K14840 READ J4845 GOSUB 54504850 NEXT K4855 NEXT I4900 REM4905 REM                                                   *** DIODE ***4910 REM4915 I$="DIODE;"4920 A$=I$&"FUNC?;"4925 GOSUB 5004930 GOSUB 6004935 IF B$=I$ THEN 50004940 GOSUB 58005000 REM5005 REM                                           *** AVE, NUL, DBR ***5010 REM5015 V=15020 RESTORE 60655025 FOR I=1 TO 35030 READ H$5031 IF I<2 THEN 50355032 FOR J=-19001 TO -1 STEP 10005033 GOSUB 55005034 NEXT J5035 FOR J=19001 TO 1 STEP -10005040 GOSUB 55005045 NEXT J5050 NEXT I5100 REM5105 REM                                           *** LIMITS, RATIO ***5110 REM5115 V=25120 RESTORE 61155125 FOR I=1 TO 25130 READ H$5135 FOR K=19001 TO -19001 STEP -10005140 J1=-1*K5145 J2=K5150 GOSUB 55555155 NEXT K5160 NEXT I5165 REM5168 REM                                               *** RDY, SEND ***5171 REM5174 V=05177 A$="INIT;"5180 GOSUB 5005183 A$="OHMS;RDY?;SEND;"5186 I$="RDY  0;1.E+99;"5189 GOSUB 56505190 FOR K=1 TO 10005191 REM  Allow time for DM to become 'ready'5192 NEXT K5193 A$="RDY?;"5195 I$="RDY  1;"5198 GOSUB 56505200 REM5205 REM                                                    *** ERR? ***5210 REM5215 A$="INIT;ERR?"5220 I$="ERR  0;"5225 GOSUB 5005230 GOSUB 6005235 REM ^^^ Flush out last error code5240 GOSUB 5005245 GOSUB 6005250 REM ^^^ Get up-dated Error Register5255 IF B$=I$ THEN 52655260 GOSUB 58005265 NEXT L15270 RETURN 5300 REM5305 REM                                          *** HEADER & 'OFF' ***5310 REM5315 A$=H$&" OFF"5320 Q$=H$5325 GO TO 56005350 REM5355 REM                                           *** HEADER & 'ON' ***5360 REM5365 A$=H$&" ON"5370 Q$=H$5375 GO TO 56005400 REM5405 REM                             *** HEADER & ARGUMENT & HEADER? ***5410 REM5415 A$=H$&" "5420 A$=A$&S$5425 Q$=H$5430 GO TO 56005450 REM5455 REM                               *** HEADER & STR(J) & 'FUNC?' ***5460 REM5465 A$=H$&" "5470 S$=STR(J)5475 A$=A$&S$5480 Q$="FUNC"5485 GO TO 56005500 REM5505 REM                               *** HEADER & STR(J) & HEADER? ***5510 REM5515 S$=STR(J)5520 A$=H$&" "5525 A$=A$&S$5530 Q$=H$5535 GO TO 56005550 REM5555 REM                    *** HEADER & STR(J1) & STR(J2) & HEADER? ***5560 REM5565 A$=H$&" "5570 S$=STR(J1)5575 A$=A$&S$5580 S$=STR(J2)5585 A$=A$&","5590 A$=A$&S$5595 Q$=H$5600 REM5605 REM                                                *** BUILD A$ ***5610 REM5615 A$=A$&";"5620 I$=A$5625 A$=A$&Q$5630 A$=A$&"?;"5635 GOSUB 56505640 RETURN 5650 REM5655 REM                                                 *** PUT/GET ***5660 REM5665 GOSUB 5005670 GOSUB 6005675 IF V=0 THEN 57655680 X1=POS(B$," ",1)5685 X2=POS(B$,",",X1)5690 X3=POS(B$,";",X2)5695 IF X2<>0 THEN 57055697 X2=X15705 X$=SEG(B$,X1+1,X2-X1-1)5710 Z$=SEG(B$,X2+1,X3-X2-1)5712 IF V<>2 THEN 57255715 X=VAL(X$)5720 X$=STR(X)5725 Z=VAL(Z$)5730 Z$=STR(Z)5735 B$=SEG(B$,1,X1)5740 IF V<>2 THEN 57555745 B$=B$&X$5750 B$=B$&","5755 B$=B$&Z$5760 B$=B$&";"5765 IF B$=I$ THEN 57755770 GOSUB 58005775 RETURN 5800 REM5805 REM                                                  *** SET E$ ***5810 REM5815 E$="Incorrect response to "5820 E$=E$&A$5825 GOSUB 25005830 RETURN 5900 REM5905 REM                                         *** First 6 Headers ***5910 REM5915 DATA "MONITOR","OPC","OVER","RQS","USER","LFR"5950 REM5955 REM         *** Next 5 Headers, no. of Arguments, the Arguments ***5960 REM5965 DATA "CALC",6,"AVE","RATIO","DBM","DBR","CMPR","OFF"5970 DATA "DT",2,"TRIG","OFF"5975 DATA "DIGIT",2,"3.5","4.5"5980 DATA "MODE",2,"RUN","TRIG"5985 DATA "SOURCE",2,"REAR","FRONT"6000 REM6005 REM         *** Next 4 Headers, no. of Arguments, the Arguments ***6010 REM6015 DATA "ACDC",5,0.2,2,20,200,7006020 DATA "ACV",5,0.2,2,20,200,7006025 DATA "DCV",5,0.2,2,20,200,10006030 DATA "OHMS",6,200,2000,20000,200000,2000000,2.0E+76050 REM6055 REM                                          *** Next 3 headers ***6060 REM6065 DATA "AVE","NULL","DBR"6100 REM6105 REM                                          *** Last 2 Headers ***6110 REM6115 DATA "LIMITS","RATIO"